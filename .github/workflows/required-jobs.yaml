name: Check Other Job Status

on:
  pull_request_target:
    types:
      - open
      - synchronize
      - reopened
      - labeled

jobs:
  skipper:
    runs-on: ubuntu-latest
    outputs:
      skip_build: ${{ steps.skipper.outputs.skip_build }}
      skip_test: ${{ steps.skipper.outputs.skip_test }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit-hash }}
          fetch-depth: 0
      - id: skipper
        env:
          TARGET_BRANCH: ${{ inputs.target-branch }}
        run: |
          #!/bin/bash -x
          # NOTE: keep ALL_SKIPS and skipper.outputs in sync
          ALL_SKIPS=( skip_build skip_test )
          DISABLE_SKIPS=()
          CHANGED_FILES=$(git diff --name-only "origin/${TARGET_BRANCH}")
          echo "$CHANGED_FILES"
          echo

          # ci/* doesn't require any tests, just remove them
          CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -v '^ci/')
          # **/*.{rst,md} file require only build
          echo "$CHANGED_FILES" | grep -e '\.rst$' -e '\.md$' -q && DISABLE_SKIPS+=( skip_build ) && CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -v -e '\.rst$' -e '\.md$')
          # Add more rules here; don't forget to remove treated CHANGED_FILES

          if [ -n "$CHANGED_FILES" ]; then
            # Remaining utreated files, run all tests
            for SKIP in "${ALL_SKIPS[@]}"; do
              echo "$SKIP=no" >> "$GITHUB_OUTPUT"
            done
          else
            # Set DISABLE_SKIPS to no (don't want to skip them)
            for SKIP in "${DISABLE_SKIPS[@]}"; do
              echo "$SKIP=no" >> "$GITHUB_OUTPUT"
            done
            # Now SKIP all untreated checks
            for SKIP in "${ALL_SKIPS[@]}"; do
              grep "^$SKIP=" "$GITHUB_OUTPUT" || echo "$SKIP=yes" >> "$GITHUB_OUTPUT"
            done
          fi
          echo "GH OUTPUT"
          cat "$GITHUB_OUTPUT"
        shell: /usr/bin/bash -x {0}

  check-status:
    needs: skipper
    runs-on: ubuntu-latest

    steps:
    - name: Check Other Job Status
      run: |
        # Get the current workflow run ID
        RUN_ID=$(echo $GITHUB_RUN_ID)

        # Define the required jobs
        REQUIRED_JOBS=("FOO" "BAR" "BAZ")

        # Poll interval in seconds
        POLL_INTERVAL=30

        # Get the jobs for the current workflow run
        get_jobs() {
          curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs/${RUN_ID}/jobs
        }

        sleep 60

        # Print all jobs
        echo "All jobs:"
        ALL_JOBS=$(get_jobs)
        echo $ALL_JOBS | jq -r '.jobs[].name'

        # Continuously poll the status of required jobs until any of them fails or all of them have completed
        while true; do
          all_completed=true
          for job_name in "${REQUIRED_JOBS[@]}"; do
            # Get the status of the current job
            JOB_STATUS=$(echo $ALL_JOBS | jq -r ".jobs[] | select(.name == \"$job_name\") | .status")

            # Print the status of the current job
            echo "$job_name job status: $JOB_STATUS"

            # Check if the current job failed
            if [ "$JOB_STATUS" = "completed" ]; then
              continue
            elif [ "$JOB_STATUS" = "in_progress" ]; then
              all_completed=false
            else
              echo "$job_name job failed."
              exit 1
            fi
          done

          # If all required jobs have completed, exit the loop
          if $all_completed; then
            echo "All required jobs completed."
            break
          fi

          # Sleep for the poll interval before checking again
          sleep $POLL_INTERVAL
          ALL_JOBS=$(get_jobs)
        done
